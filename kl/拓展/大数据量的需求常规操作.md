[toc]

# 大数据处理算法

## 解决办法

- **针对时间：**可以采用巧妙的算法搭配合适的数据结构，如`Bloom filter, hash, bitMap` ，堆，数据库或倒排索引。
- **针对空间：**大而化小，分而治之
- **集群/分布式：**单机处理装载的机器有限，集群适合分布式处理，并行计算。

## 分而治之

- **分而治之/`hash`映射：**针对数据太大，内存受限，把大文件化成小文件。
- **`hashMap`统计：**当大文件转化为小文件，使用常规`HashMap`来进行频率统计。
- **堆/快速排序：**统计完之后，可以采用堆排序。

## 问题

### 海量日志数据，提取出某日访问百度次数最多的那个IP?

1. 将`IP`取出来放入一个大文件中，因为`IP`是`32`位，最多有个`2^32`个IP；
2. 通过采用取模的方式`%/1000`，可以将大文件映射成1000个小文件；
3. 找出每个小文件中出现频率最大的`IP`；
4. 从这1000个`IP`中找出频率最大的那个`IP`。

### 寻找热门查询，300万个查询字符串中统计最热门的10个查询?

1. 如果每个字符我 `255Bytes`, 那么300w数据的大小为`300w * 255 / (1014 * 1024 *1024) = 0.75G`。那么将字符完全放入内存是合适的。
2. 使用`HashMap`结构来维护`key`为字符，`value`为次数的对象；
3. 当字符完全写入`Map`后，使用堆排序来找出`TopK`。

### 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词?

1. **分治法**

   顺写读取文件，采用hash取模，将文件写入5000个小文件中，每个文件200k左右；

2.  **hashMap**

   对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。

3. **堆/归并排序**

   取出出现频率最大的100个词(可以用含100个结点的最小堆)后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并

### 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10?

- 如果每个元素只出现一次，且只出现的某一台机器中。

  **堆排序**

  1. 在每台电脑上求出top10，可以采用包含10个元素的堆完成；
  2. 求出每台电脑的top10，然后把这100台电脑上的top10组合起来，再来求出top10；

- 如果同一个元素重复出现在不同的电脑上

  **哈希取模**

  1. 通过对100台电脑的数据hash取模，这样100台电脑上的数据的hash值是相同的；
  2. 对每台电脑找出top10，继而可以求出top10；

  **暴力破解**

  1. 首先对每台电脑上进行次数的统计；
  2. 然后对不同机器中的次数再次累加；
  3. 找出top10

### 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序?

**方案一**

1. **hash映射**: 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件(记为a0,a1,..a9)中。这样新生成的文件每个的大小大约也1G(假设hash函数是随机的)。

2. **hash_map统计**: 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注: hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。

3. **堆/快速/归并排序**: 利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件(记为)。最后，对这10个文件进行归并排序(内排序与外排序相结合)。

**方案二**

一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。

**方案三**

 与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理(比如MapReduce)，最后再进行合并。

### 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?

可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

1. **分而治之/hash映射**: 遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件(记为，这里漏写个了a1)中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中(记为)。这样处理后，所有可能相同的url都在对应的小文件()中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
2. **hash_set统计**: 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

1. 对a, b两个文件分别作hash，写入不同的小文件中，那么每个小文件的hash数据是相同的，
2. 然后通过对比两个相同hash的小文件，比如布隆或者hashset。

### 怎么在海量数据中找出重复次数最多的一个?

先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求

### 上千万或上亿数据(有重复)，统计其中出现次数最多的前N个数据?

上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据

### 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析?

**方案1**

1. 如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，
2. 对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，
3. 然后再进行归并处理，找出最终的10个最常出现的词。

**方案2**

1. 通过hash取模将大文件分解为多个小文件后，
2. 除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数。
3. 最终同样找出出现最频繁的前10个词

### 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解?

1. 首先根据用hash并求模，将文件分解为多个小文件，
2. 对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。
3. 然后再进行归并处理，找出最终的10个最常出现的词。

###  100w个数中找出最大的100个数

**方案1**

1. 采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比;
2. 如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。
3. 依次循环，知道扫描了所有的元素。

**方案2**

1. 采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候;
2. 采用传统排序算法排序，取前100个。

**方案3**

 在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。

### 5亿个int找它们的中位数?

**方案一**

1. 首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数;
2. 之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。
3. 然后第二次扫描我们只统计落在这个区域中的那些数就可以了。

### 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。

**方案1**

1.  采用2-Bitmap(每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义)进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。
2. 然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。
3. 所描完事后，查看bitmap，把对应位是01的整数输出即可。

**方案2**

1. 可采用分治，划分小文件的方法。
2. 然后在小文件中找出不重复的整数，并排序。
3. 然后再进行归并，注意去除重复的元素。

### 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中?

用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。
